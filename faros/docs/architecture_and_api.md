# FAROS Architecture & API Reference

## System Overview

FAROS is a multi-robot welding operations platform comprising three independently
running services coordinated by the RobTrack PySide6 desktop application. The
desktop app spawns each service as a background process and embeds the React
frontend inside a `QWebEngineView`.

```
┌──────────────────────────────────────────────────────────────┐
│               RobTrack Desktop  (PySide6)                    │
│                                                              │
│   src/gui/faros_page/faros_page.py                           │
│   ├── QWebEngineView  ──→  React App  (localhost:5174)       │
│   ├── InferenceService  (in-process model cache)             │
│   │   └── LocalFilesystemProvider                            │
│   └── Subprocess Manager  ──→  spawns 3 child processes      │
└───────────────┬──────────────────────────────────────────────┘
                │
     ┌──────────┼───────────────────┐
     ▼          ▼                   ▼
  React App   Viser Server       MCCP DevLab API
  :5174       :8081 / :8082      :8091
  (Vite)      (HTTP + WS)       (HTTP)
```

### Service Inventory

| Service | Technology | Default Ports | Source |
|---------|-----------|--------------|--------|
| React Frontend | React 19, Vite 7, TypeScript, Tailwind CSS 4 | 5174 | `faros/frontend/` |
| Viser 3D Server | Python, Viser, WebSockets, Trimesh, YourDFPy | 8081 (HTTP), 8082 (WS) | `faros/services/viser_server.py` |
| MCCP DevLab API | Python, ThreadingHTTPServer, TensorFlow/Keras | 8091 | `faros/services/mccp_inference_devlab_server.py` |
| Qt Integration | PySide6, QWebEngineView | - | `src/gui/faros_page/` |

---

## 1. React Frontend

### 1.1 Component Hierarchy

```
main.tsx
└── App.tsx
    └── FarosPage.tsx          ← centralised state, tab routing
        ├── TopBar.tsx          ← connection status, session mode, latency
        ├── Sidebar.tsx         ← tab navigation (7 tabs)
        └── <active tab>
            ├── LiveOps.tsx           ← cockpit: robot cards, 3D view, telemetry
            ├── RobotsTab.tsx         ← per-robot details & controls
            ├── ModelsTrustTab.tsx     ← model routing & trust thresholds
            ├── MLOpsTab.tsx          ← embedded MLOps Orchestrator (iframe)
            ├── InferenceDevLabTab.tsx ← MCCP-UQ dev testing interface
            ├── HistoryTab.tsx        ← run summaries & audit log
            └── SettingsTab.tsx       ← dark mode, chart freeze, thresholds
```

### 1.2 State Management

All application state lives in `FarosPage.tsx` using React hooks (`useState`,
`useEffect`, `useMemo`). State is passed down via props - no external state
library is used.

**Key state domains:**

| Domain | Variables | Updated by |
|--------|-----------|-----------|
| Navigation | `tab` | Sidebar click |
| Robots | `robots` (A & B state objects) | Simulated interval (1 s) |
| Trust | `trustFeed`, `latestTrustA/B`, thresholds | Simulated interval (1 s) |
| Telemetry | `telemetry[]`, `metric`, `showRobot` | Simulated interval (1 s) |
| Alerts | `alerts[]` | Trust threshold breach events |
| Connections | `connections` (ros, viser, mccp, mlops) | Random drift (~3 % / tick) |
| Visualisation | `vizMode`, `layers`, `camera`, `timelineT` | User interaction |
| Model routing | `routing` (PA/PC model assignments) | User selection |
| Settings | `darkMode`, `sessionMode`, `freezeCharts` | User toggles |

> **Note:** Most telemetry and robot state is currently mock/simulated data
> generated by `useEffect` intervals. Real integrations are scaffolded
> (WebSocket bridge, HTTP API calls) but production data sources are not yet
> connected.

### 1.3 Tabs at a Glance

**Live Ops** - Primary operator cockpit. Left panel: robot control cards
(start / pause / resume / abort) and alerts feed. Centre: Viser 3D viewer
embedded via iframe. Right: real-time telemetry charts (Recharts) and trust
assessment panel.

**Robots** - Detailed per-robot view showing state, telemetry readings (speed,
current, voltage, bead width/height), trust scores, and control buttons.

**Models & Trust** - Position-based model routing (PA / PC dropdowns), trust
threshold sliders (warn / stop), trust confidence chart, model registry table,
and audit log.

**MLOps** - Embeds the MLOps Orchestrator UI (port 5173) in an iframe. Shows
pipeline run summaries, model routing overview, and latest artifact metadata.

**Inference DevLab** - Developer-facing MCCP-UQ testing tool. Connects to the
MCCP DevLab API via HTTP. Features: health check, workspace root configuration,
JSON feature editor, and prediction result visualisation (intervals, widths,
midpoints).

**History** - Historical run summaries table (beads completed, trust averages)
and full audit log. Export buttons for CSV/PDF (not yet implemented).

**Settings** - Dark mode toggle, chart freeze, replay timeline, trust threshold
sliders, and connection status simulation.

### 1.4 External Connections (Frontend)

| Protocol | Target | Direction | Used by |
|----------|--------|-----------|---------|
| WebSocket | `ws://localhost:8082` | Frontend → Viser | `useViserBridge` hook |
| HTTP GET | `http://localhost:8091/health` | Frontend → MCCP API | InferenceDevLabTab |
| HTTP POST | `http://localhost:8091/config` | Frontend → MCCP API | InferenceDevLabTab |
| HTTP POST | `http://localhost:8091/predict` | Frontend → MCCP API | InferenceDevLabTab |
| iframe | `http://localhost:8081` | Embed | LiveOps (Viser viewer) |
| iframe | `http://localhost:5173` | Embed | MLOpsTab (orchestrator) |

### 1.5 Viser WebSocket Bridge

The `useViserBridge` hook maintains a persistent WebSocket connection to the
Viser server. It sends robot state updates throttled at **200 ms**:

```json
{
  "robotA": { "state": "Running", "beadIndex": 3, "progressPct": 42.5 },
  "robotB": { "state": "Idle",    "beadIndex": 0, "progressPct": 0.0 }
}
```

Auto-reconnects after 2 seconds on disconnect.

### 1.6 TypeScript Types

Core domain types are defined in `faros/frontend/src/types/index.ts`:

- `RobotState`: `"Idle" | "Running" | "Paused" | "Fault" | "E-Stop"`
- `TrustGate`: `"OK" | "Warning" | "Stop"`
- `ConnStatus`: `"green" | "yellow" | "red"`
- `TabKey`: `"live" | "robots" | "models" | "mlops" | "inference" | "history" | "settings"`
- `RobotCell`: Full robot state (id, name, position, state, progress, trust, telemetry)
- `MeasurementPoint`: Telemetry sample (speed, current, voltage, bead dims, confidence)
- `ModelVersion`: Registry entry (id, name, position, trust score, artifact path)
- `TrustAssessment`: Runtime trust evaluation (confidence, gate, reasons)
- `Alert`, `AuditLogEntry`, `RunSummary`, `PipelineRun`

### 1.7 Build & Dev Server

```bash
cd faros/frontend
npm install
npm run dev        # Vite dev server on :5174
npm run build      # Production build (tsc + vite build)
npm run lint       # ESLint
```

**Vite environment variables** (`.env` or runtime):

| Variable | Default | Description |
|----------|---------|-------------|
| `VITE_VISER_URL` | `http://localhost:8081` | Viser 3D server URL |
| `VITE_MLOPS_URL` | `http://localhost:5173` | MLOps Orchestrator URL |
| `VITE_MCCP_API_URL` | `http://localhost:8091` | MCCP inference API URL |

---

## 2. Viser 3D Server

### 2.1 Overview

A Python server providing a browser-accessible 3D scene (via Viser) and a
WebSocket bridge that accepts robot state from the React app to drive robot
joint animation.

### 2.2 Scene Composition

On startup, the server loads:

1. **Workpiece plate** - STL mesh at `faros/frontend/public/assets/motion/workpieces/`
2. **Robot A (UR5)** - URDF + DAE meshes at `faros/frontend/public/assets/robots/robot_a/`
3. **Robot B (UR3)** - URDF + DAE meshes at `faros/frontend/public/assets/robots/robot_b/`
4. **World frame + grid** - Reference axes and ground plane

### 2.3 Animation Loop

Runs at ~30 fps (`dt = 0.033 s`):

- **Running**: Advances per-robot animation time and computes a looping
  sinusoidal joint trajectory (`welding_loop_cfg`). Phase offsets differentiate
  robots and bead indices.
- **Idle**: Smoothly interpolates back to the initial (home) configuration with
  exponential smoothing (`alpha = 0.1`).
- **Paused**: Holds the current pose, no time advancement.

### 2.4 WebSocket Protocol

See [1.5 above](#15-viser-websocket-bridge). The server side uses `websockets`
(asyncio) running in a daemon thread. State is transferred to the main loop via
a thread-locked `latest_state` dictionary.

### 2.5 Configuration

| Variable | Default | Description |
|----------|---------|-------------|
| `VISER_PORT` | `8081` | Viser HTTP port |
| `VISER_WS_PORT` | `8082` | WebSocket bridge port |

---

## 3. MCCP Inference DevLab API

### 3.1 Overview

A lightweight HTTP server exposing the MCCP-UQ (Monte Carlo Conformal
Prediction with Uncertainty Quantification) inference engine to the React
Inference DevLab tab.

Built on `http.server.ThreadingHTTPServer` - one thread per request with a
global `threading.Lock` protecting the model runtime.

### 3.2 Endpoints

#### `GET /health`

Returns model availability, load status, and configured paths.

**Response** `200 OK`:
```json
{
  "ok": true,
  "model_available": true,
  "loaded": true,
  "workspace_root": "/path/to/shared-workspace",
  "model_path": "/path/to/shared-workspace/models/mccp-uq/model.h5",
  "state_path": "/path/to/shared-workspace/state/mccp-uq/mccp_state.pkl"
}
```

#### `POST /config`

Update the workspace root at runtime. Resets the loaded model so it reloads
from the new path on the next prediction.

**Request**:
```json
{
  "workspace_root": "/new/path/to/shared-workspace"
}
```

**Response** `200 OK`:
```json
{
  "ok": true,
  "workspace_root": "/new/path/to/shared-workspace",
  "model_path": "...",
  "state_path": "...",
  "model_available": true,
  "detail": "Workspace updated."
}
```

**Errors**: `400` if path missing or directory doesn't exist.

#### `POST /predict`

Run MCCP-UQ inference on a batch of input features.

**Request**:
```json
{
  "input_features": [[0.7, 600.0, 300.0, 150.0, 7.0, 3, 0.1, 3]],
  "target_dim": 2,
  "reload_if_stale": true
}
```

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `input_features` | `float[][]` | *(required)* | 2D array, shape `(n_samples, n_features)` |
| `target_dim` | `int` | `2` | Number of target variables |
| `reload_if_stale` | `bool` | `true` | Reload model if artifacts changed on disk |

**Response** `200 OK`:
```json
{
  "ok": true,
  "target_dim": 2,
  "sample_count": 1,
  "lower": [[12.34, 56.78]],
  "upper": [[15.67, 62.10]],
  "intervals": [3.33, 5.32],
  "widths": [[3.33, 5.32]],
  "midpoint": [[14.005, 59.44]]
}
```

**Errors**: `404` if artifacts missing, `400` for invalid input.

#### `OPTIONS /*`

CORS preflight - returns `204 No Content` with permissive CORS headers
(`Access-Control-Allow-Origin: *`).

### 3.3 Runtime Lifecycle

```
Server start
  │
  ├── InferenceRuntime created (workspace_root from env or placeholder)
  │
  ├── First /predict request
  │     ├── ensure_loaded() acquires lock
  │     │     ├── artifacts_exist()? → load_artifacts() from disk
  │     │     └── mtime recorded for staleness tracking
  │     └── predict() runs MC dropout + CQR under lock
  │
  ├── Subsequent /predict requests
  │     ├── is_stale()? compare mtime → reload if changed
  │     └── predict() with cached model
  │
  └── POST /config
        ├── Update workspace_root under lock
        └── Reset model/state to None (lazy reload on next predict)
```

---

## 4. MCCP-UQ Inference Engine

### 4.1 Pipeline

Located in `faros/inference/mccp_inference.py`. The engine is also duplicated
in `src/gui/faros_page/mccp_inference.py` for use by the in-process
`InferenceService`.

```
Input Features  (n_samples, n_features)
       │
       ▼
  load_artifacts()
  ├── Keras model from .h5
  └── MCCP state from .pkl (via mccp_lib stub)
       │
       ▼
  dynamic_mc_predict()
  ├── Per-sample stochastic forward passes (dropout active)
  ├── Variance tracking until stabilisation
  │   └── Stops when var_diff <= min_delta for `patience` iterations
  │       or after `max_mc` passes
  └── Returns mean predictions (n_samples, n_quantiles)
       │
       ▼
  Split quantiles → x_lower[:, 0], x_upper[:, 1]
       │
       ▼
  cqr_predict()
  ├── lower_pred = val_lower - q_hat
  ├── upper_pred = val_upper + q_hat
  └── intervals  = mean(upper - lower) per target
       │
       ▼
  Output: { lower, upper, intervals }
```

### 4.2 mccp_lib Pickle Stub

The calibration state (`.pkl`) was serialised by the MLOps Orchestrator's
`mccp_lib` package. To deserialise without that dependency, a minimal stub
class is registered in `sys.modules` at import time:

```
sys.modules['mccp_lib.mccp.mccp'].MCCP  →  empty class
```

### 4.3 GPU Configuration

GPU is **disabled by default** (`MCCP_USE_GPU=0`) to avoid CUDA/cuDNN version
issues. When disabled, `tf.config.set_visible_devices([], 'GPU')` is called at
import time.

---

## 5. Qt Integration Layer

### 5.1 FarosPage Widget

`src/gui/faros_page/faros_page.py` - a `QWidget` added to the main window's
`QStackedWidget`. It:

1. Creates a persistent `QWebEngineProfile` with local storage and cookies.
2. Loads the React app URL in a `QWebEngineView`.
3. Spawns the three background services (Viser, React, MCCP API).
4. Registers cleanup hooks (`aboutToQuit`, `atexit`).

### 5.2 Process Management

Before starting each process, `_port_in_use()` checks for conflicts using:
1. A TCP connect probe (IPv4/IPv6, 300 ms timeout).
2. A bind-attempt fallback (detects `EADDRINUSE` / `EACCES`).

If a port is already in use, the process is skipped (assume external instance).

Cleanup calls `terminate()` (5 s timeout) then `kill()` (2 s timeout) as a
fallback. Order: processes first, then WebEngine objects (page → view →
profile).

### 5.3 InferenceService (In-Process Cache)

`src/gui/faros_page/inference_service.py` provides an in-process alternative to
the HTTP API:

- **Lazy loading**: Loads model on first `predict()` or explicit `load()`.
- **Staleness detection**: Compares file mtimes; `reload_if_stale()` refreshes
  automatically.
- **Provider abstraction**: `ModelProvider` → `LocalFilesystemProvider` reads
  from `MCCP_WORKSPACE_ROOT`.

### 5.4 MLOps Widget

`src/gui/faros_page/mlops_widget.py` - a standalone `QWebEngineView` widget
that embeds the MLOps Orchestrator at `http://{HOST_IP}:5173`. Includes a
toolbar with Refresh and "Open in Browser" buttons.

---

## 6. Environment Variables Reference

| Variable | Default | Scope | Description |
|----------|---------|-------|-------------|
| `FAROS_HOST` | `localhost` | Qt | React app hostname |
| `FAROS_PORT` | `5174` | Qt, React | React dev server port |
| `VISER_PORT` | `8081` | Qt, Viser | Viser HTTP port |
| `VISER_WS_PORT` | `8082` | Qt, Viser | Viser WebSocket port |
| `MCCP_API_HOST` | `0.0.0.0` | MCCP API | API bind address |
| `MCCP_API_PORT` | `8091` | Qt, MCCP API | API HTTP port |
| `MCCP_WORKSPACE_ROOT` | *(none)* | MCCP API, Qt | Path to MLOps shared-workspace |
| `MCCP_USE_GPU` | `0` | Inference | `1` to enable GPU inference |
| `FAROS_AUTO_START_VISER` | `1` | Qt | `0` to disable Viser autostart |
| `FAROS_AUTO_START_REACT` | `1` | Qt | `0` to disable React autostart |
| `FAROS_AUTO_START_MCCP_DEVLAB` | `1` | Qt | `0` to disable MCCP API autostart |
| `HOST_IP` | `localhost` | MLOps Widget | MLOps Orchestrator hostname |
| `VITE_VISER_URL` | `http://localhost:8081` | React | Viser URL for iframe |
| `VITE_MLOPS_URL` | `http://localhost:5173` | React | MLOps URL for iframe |
| `VITE_MCCP_API_URL` | `http://localhost:8091` | React | MCCP API base URL |

---

## 7. Data Flow Diagrams

### 7.1 Robot Control & Visualisation

```
User clicks "Start Robot A" in LiveOps
  │
  ▼
FarosPage sets robots.robotA.state = "Running"
  │
  ├──→ LiveOps re-renders control card
  │
  └──→ useViserBridge sends WS message (throttled 200 ms)
         │
         ▼
       Viser WS handler updates latest_state['robotA']
         │
         ▼
       Animation loop reads state under lock
         │
         ▼
       welding_loop_cfg() → update_robot_pose() → FK → mesh transforms
         │
         ▼
       Viser scene updated → visible in iframe
```

### 7.2 MCCP-UQ Inference (via DevLab)

```
User fills features in InferenceDevLabTab → clicks "Run Prediction"
  │
  ▼
POST /predict { input_features, target_dim }
  │
  ▼
MCCPDevLabHandler.do_POST()
  ├── parse & validate input
  ├── runtime.ensure_loaded()  (lock)
  │     └── load_artifacts() if not loaded or stale
  └── predict()  (lock)
        ├── dynamic_mc_predict() - adaptive MC dropout
        ├── split quantiles
        └── cqr_predict() - conformal correction
  │
  ▼
Response: { lower, upper, intervals, widths, midpoint }
  │
  ▼
InferenceDevLabTab renders prediction intervals
```

### 7.3 Process Lifecycle

```
FarosPage.__init__()
  │
  ├── _start_background_processes()
  │     ├── [port check] → Popen(viser_server.py)
  │     ├── [port check] → Popen(npm run dev)
  │     └── [port check] → Popen(mccp_devlab_server.py)
  │
  ├── QApplication.aboutToQuit → _cleanup_processes()
  ├── atexit.register → _cleanup_processes()
  │
  └── closeEvent / deleteLater
        ├── _cleanup_processes()  [terminate → kill]
        └── _cleanup_webengine()  [page → view → profile]
```
